[project]
name = "cloudbot"
requires-python = ">=3.10"
version = "1.5.0"

[tool.isort]
line_length = 80
known_first_party = ["cloudbot", "plugins", "tests"]
known_third_party = ["alembic"]
float_to_top = true
profile = "black"

[tool.black]
line-length = 80
include = '\.pyi?$'

[tool.mypy]
namespace_packages = true
python_version = "3.10"
warn_unused_configs = true
strict = false
strict_optional = true
ignore_missing_imports = true
check_untyped_defs = true
show_error_codes = true
warn_unused_ignores = true
warn_redundant_casts = true
# strict_equality = true
plugins = ["pydantic.mypy"]
follow_imports = "silent"
# disallow_any_generics = true
no_implicit_reexport = true
enable_error_code = [
    "deprecated",
    "exhaustive-match",
    # "explicit-override",
    "ignore-without-code",
    "mutable-override",
    # "possibly-undefined",
    # "redundant-expr",
    "redundant-self",
    "truthy-bool",
    "truthy-iterable",
    "unimported-reveal",
    # "unused-awaitable",
    "unused-ignore",
]

[[tool.mypy.overrides]]
module = 'cloudbot.*'
warn_return_any = true

[[tool.mypy.overrides]]
module = 'cloudbot.config'
disallow_untyped_defs = true

[[tool.mypy.overrides]]
module = 'cloudbot.util.*'
warn_return_any = true

[[tool.mypy.overrides]]
module = 'plugins.cryptocurrency'
warn_return_any = true

[tool.pydantic-mypy]
init_forbid_extra = true
init_typed = true
warn_required_dynamic_aliases = true

[tool.autoflake]
remove-all-unused-imports = true
in-place = true
expand-star-imports = true

[tool.pytest.ini_options]
addopts = [
    "--ignore=venv",
    "--ignore=.*",
    "--ignore=tools",
    "--ignore=alembic",
    "--cov=.",
    "--cov-report=xml",
    "--cov-report=html",
    "--doctest-modules",
    "--random-order",
    "--pythonhashseed=123",
]
testpaths = ["."]
filterwarnings = [
    "error",
    "ignore:.*asyncio\\.iscoroutinefunction.*:DeprecationWarning:mcstatus.*",
]
asyncio_mode = "strict"
asyncio_default_fixture_loop_scope = "function"
minversion = "8.0"

[tool.coverage.report]
fail_under = 80
exclude_lines = [
    "@overload",
    "if TYPE_CHECKING:", # Type checking blocks are never accessible at test/runtime
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "class .*\\(.*(Error|Exception)\\):",
    "^ *\\.\\.\\.$",
    "raise ShouldBeUnreachable",
    "if __name__ == .__main__.:",
]

[tool.coverage.run]
branch = true
omit = [
    "tests/data/*",
    "tests/util/*",
    ".*", # Ignore any .cache, .venv, etc directories
    "venv/*",
    "tools/*", # Build/CI tools
    "alembic/*",
]
relative_files = true

[tool.nitpick]
style = [
    "gh://TotallyNotRobots/nitpick/app-style-3.10.toml",
]

[tool.flynt]
transform-concats = true
transform-joins = true
line-length = 120
aggressive = true

[tool.codespell]
skip = './data'
count = true
quiet-level = 3
ignore-words-list = ["cypher", "decypher", "AHD", "ahd", "astroid"]

[tool.ruff]
line-length = 80

[tool.ruff.lint]
ignore = [
    "ANN001", # missing function arg type annotation
    "ANN002", # no annotation for *args
    "ANN003", # no annotation for kwargs
    "ANN201", # missing return type annotation
    "ANN202", # missing return type for private function
    "ANN204", # missing return type for special method
    "ANN205", # missing return type for staticmethod
    "ANN206", # missing return type for classmethod
    "ANN401", # dynamically typed expressions
    "ARG001", # unused function arg
    "ARG002", # Unused arg
    "ARG003", # unused arg in class method
    "ARG004", # unused staticmethod args
    "ARG005", # unused lambda arg
    "ASYNC110", # use asyncio.Event
    "ASYNC251", # no time.sleep in async func
    "B007", # unused loop var
    "B011", # don't assert False
    "B024", # abstract class no abstract methods
    "B027", # abstract empty method
    "B028", # missing stacklevel
    "B905", # strict zip
    "BLE001", # catching Exception
    "C406", # unnecessary list literal
    "C416", # unnecessary list comp
    "C417", # replace map with generator
    "C420", # unnecessary dict comprehension
    "C901", # complex code
    "COM812", # trailing comma
    "D", # Don't check docs
    "D400", # first line should end with period
    "D415", # end doc with punctuation
    "DTZ", # set timezone for all datetimes
    "E501", # line too long
    "E731", # don't assign lambda
    "E741", # ambiguous var name
    "EM101", # Exception must not use a string literal, assign to variable first
    "EM102", # don't use f-string for exception message, assign to var
    "ERA001", # commented-out code
    "FBT001", # boolean typed positional arg
    "FBT002", # boolean positional arg
    "FBT003", # boolean positional arg
    "FIX002", # line has todo
    "FURB129", # replace readlines() with iter
    "FURB167", # re.I alias
    "FURB177", # Path.cwd()
    "FURB188", # str.removesuffix
    "I001", # unsorted import block
    "INP001", # namespace packages
    "N802", # bad function name
    "N806", # variable case
    "N818", # exception class name
    "PERF102", # use dict.values
    "PERF203", # try-except in loop
    "PERF401", # list comp
    "PIE808", # unnecessary start in range
    "PIE810", # merge startswith
    "PLC0206", # consider using dict.items
    "PLR0911", # too-many-return-statements
    "PLR0912", # too-many-branches
    "PLR0913", # too-many-arguments
    "PLR0915", # too-many-statements
    "PLR1730", # replace if with max
    "PLR2004", # Magic value
    "PLR2044", # line with empty comment
    "PLW1641", # no __hash__
    "PLW2901", # shadowing loop var
    "PLW3301", # nested max calls
    "PT001", # bare fixture annotation
    "PT006", # parameterize non-tuple args
    "PT007", # use list of tuples for parameterize
    "PT011", # broad pytest.raises
    "PT015", # assertion always fails
    "PT017", # use pytest.raises
    "PT018", # split assertions
    "PT022", # missing teardown
    "PT023", # bare asyncio mark
    "PTH103", # use Path.mkdir
    "PTH120", # use Path.parent
    "PTH123", # use Path.open()
    "PTH201", # don't pass current dir to path
    "PTH208", # use pathlib iterdir
    "RET501", # explicit return None
    "RET502", # implicit return None
    "RET503", # missing explicit return
    "RET504", # unnecessary assignment before return
    "RSE102", # unnecessary parentheses
    "RUF005", # list star instead of concat
    "RUF006", # store result from asyncio.ensure_future
    "RUF022", # unsorted __all__
    "RUF023", # sort slots
    "S101", # use of assert
    "S105", # possible hardcoded password
    "S113", # requests without timeout
    "S310", # url open scheme, disallow file: and others
    "S311", # insecure random source
    "S603", # subprocess untrusted input
    "S606", # starting process without a shell
    "SIM102", # combine if
    "SIM103", # return condition
    "SIM105", # suppress exception
    "SIM108", # ternary
    "SIM110", # use all()
    "SIM114", # combine if
    "SIM115", # open-with
    "SIM118", # dict.keys contains
    "SIM201", # use !=
    "SLF001", # private memnber access
    "T201", # found print
    "TD002", # missing author in todo
    "TD003", # no issue link
    "TD004", # missing colon in todo
    "TRY002", # create own exceptions
    "TRY003", # avoid specifying long messages outside of the exception class
    "TRY300", # use try-except-else
    "TRY400", # use logging.exception
]
select = [
    "ALL",
]
extend-safe-fixes = ["TC", "UP", "RUF046"]
future-annotations = true
fixable = ["ALL"]

[tool.ruff.lint.flake8-type-checking]
runtime-evaluated-base-classes = ["pydantic.BaseModel", "sqlalchemy.orm.DeclarativeBase", "cloudbot.util.database.Base"]

[tool.alembic]
# path to migration scripts.
# this is typically a path given in POSIX (e.g. forward slashes)
# format, relative to the token %(here)s which refers to the location of this
# ini file
script_location = "%(here)s/alembic"
# additional paths to be prepended to sys.path. defaults to the current working directory.
prepend_sys_path = ["."]

# [[tool.alembic.post_write_hooks]]
# lint with attempts to fix using "ruff" - use the module runner, against the "ruff" module
# name = "ruff"
# type = "module"
# module = "ruff"
# options = "check --fix REVISION_SCRIPT_FILENAME"
#
# [[tool.alembic.post_write_hooks]]
# Alternatively, use the exec runner to execute a binary found on your PATH
# name = "ruff"
# type = "exec"
# executable = "ruff"
# options = "check --fix REVISION_SCRIPT_FILENAME"
